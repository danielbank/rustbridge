<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Text Adventure - Rustbridge workshop kit</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="intro.html">Introduction</a></li><li><a href="./beginners/README.html"><strong>1.</strong> Beginners</a></li><li><ul class="section"><li><a href="./beginners/tutorial-text.html"><strong>1.1.</strong> Tutorial</a></li></ul></li><li><a href="./installfest/README.html"><strong>2.</strong> Installfest</a></li><li><ul class="section"><li><a href="./installfest/user-guide.html"><strong>2.1.</strong> User guide</a></li><li><a href="installfest/presentation-outline.html"><strong>2.2.</strong> Presenter notes</a></li></ul></li><li><a href="./machine_learning/readme.html"><strong>3.</strong> Spam Or Ham?</a></li><li><a href="./mondrian-pattern/README.html"><strong>4.</strong> Mondrian Pattern Generator</a></li><li><ul class="section"><li><a href="./mondrian-pattern/part1.html"><strong>4.1.</strong> Part 1</a></li><li><a href="./mondrian-pattern/part2.html"><strong>4.2.</strong> Part 2 (WIP)</a></li><li><a href="./mondrian-pattern/CONTRIBUTING.html"><strong>4.3.</strong> Speaker notes</a></li></ul></li><li><a href="./textadventure/textadventure.html" class="active"><strong>5.</strong> Text Adventure</a></li><li><a href="./url_shortener/README.html"><strong>6.</strong> URL Shortener</a></li><li><a href="./web-scraper/README.html"><strong>7.</strong> Web Scraper</a></li><li><ul class="section"><li><a href="./web-scraper/doc/demo.html"><strong>7.1.</strong> Tutorial</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Rustbridge workshop kit</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="./textadventure/textadventure.html#text-adventure" name="text-adventure"><h1>Text Adventure</h1></a>
<p><a href="https://github.com/rust-community/rustbridge/tree/master/workshops/src/textadventure">Code</a></p>
<p>For this workshop, let’s add various features to a simple text adventure game written in Rust.</p>
<p>Here's what we have to work with:</p>
<p><strong>Game Board</strong> - A 5 by 5 grid containing a total of 25 rooms.</p>
<p><strong>Rooms</strong> - A room may have up to 4 <strong>Walls</strong>. Each wall may be:</p>
<ul>
<li><strong>Open</strong> which will allow unrestricted passage through.</li>
<li><strong>Solid</strong> which will prevent passage.</li>
<li><strong>Magical</strong> which will allow passage only with a secret word.</li>
<li>The walls can be configured to form a maze.</li>
<li>A room can be light or dark depending on whether or not it contains a torch.</li>
</ul>
<p><strong>Characters</strong> - We will have 3 kinds of characters.</p>
<ul>
<li>You the adventurous <strong>Explorer</strong>, wandering from room to room.</li>
<li><strong>Leprechauns</strong> the good wee people with a mischievous sense of humour. They can give you gold or <strong>Magic Words</strong> but you never know if they are telling the truth. They can teleport to any room.</li>
<li><strong>Gnomes</strong> who guard the treasures of the earth and just might take your stuff if you’re not careful. They can go one space in any direction - they know the magic word to walk through any kind of wall.</li>
</ul>
<p><strong>Things</strong> - Things can be picked up and exchanged by characters.</p>
<ul>
<li><strong>Food</strong> gives you <strong>Energy</strong> to keep going.</li>
<li><strong>Gold</strong> pays the way.</li>
<li><strong>Fake Gold</strong> is given to you by mischievous leprechauns - also good for giving to gnomes.</li>
<li><strong>Teleporter</strong> moves you at random to some other room.</li>
<li><strong>Torch</strong> allows you to see in a dark room - tells you what’s in a dark room.</li>
</ul>
<p><strong>Moves</strong></p>
<ul>
<li><strong>North</strong> or <strong>South</strong> allows you to move up or down by one space.</li>
<li><strong>East</strong> or <strong>West</strong> allows you to move right or left by one space.</li>
<li><strong>Teleport</strong> allows you to teleport to some other room if you have a teleporter.</li>
<li>Each move consumes 1 food unit and teleporting consumes 5.</li>
</ul>
<p>Much of the game has already been implemented for you but is not very playable.  Your job is to implement the remaining TODOs so that the game plays according to the rules listed above.  All the Rust code for the game is in the src directory.  The code already compiles and runs although there are numerous compiler warnings.  These warnings should disappear as you build out the rest of the game.  Look at the game loop in main.rs to get an idea of how the game is structured then begin adding your missing code to the players, board and inventory modules.</p>
<p>As you add more of your code to your game use Cargo to check it and ensure that it still compiles. Run the game from the command line to try out new features as you implement them. For how to get started with Rust and its Cargo tool see <a href="http://rust-lang.github.io/book/second-edition/ch02-00-guessing-game-tutorial.html">Chapter 2</a> of <a href="http://rust-lang.github.io/book/second-edition"><em>The Rust Programming Language</em></a> book.  Other good resources for learning Rust syntax and semantics are <a href="http://rustbyexample.com"><em>Rust by Example</em></a> and <a href="https://github.com/carols10cents/rustlings"><em>Rustlings</em></a> project.</p>
<p>Here is the order I recommend implementing the remaining features:</p>
<ul>
<li>
<p>First implement the is_opening function in board.rs.</p>
</li>
<li>
<p>Next implement the move_exp_north, move_exp_east, move_exp_south and move_exp_west explorer navigation functions in players.rs.  See move_gnome for the mechanics of how these work.  Keep in mind that unlike move_gnome an explorer's navigation functions are invoked interactively by the user and an explorer can only walk through openings or magical walls.  I wouldn't worry about magical walls or secret words yet.  Just treat any magical walls as solid for now.  Don't forget that moving one space or walking into a wall consume 1 unit of an explorer's energy per turn.</p>
</li>
<li>
<p>Now implement the teleport_lep and teleport_exp functions in players.rs.  See move_gnome for how to move an NPC at random.  Unlike gnomes which always move only one space every turn teleporting can put a player anywhere on the board.  The teleport_exp function returns a bool because an explorer can only teleport if she has a teleporter.  See the build_players function to get an idea of what an explorer's things are.  Don't forget that teleporting consumes 5 units of an explorer's energy.  Leprechauns are tireless so they don't lose any energy.</p>
</li>
<li>
<p>Next implement the exp_has_torch function in inventory.rs and the room_has_torch function in board.rs.  Now the explorer can see the contents of rooms since she is already carrying a torch.  Similarly, if an explorer has no torch but enters a room containing one she can pick up that torchh because the room is already lit by it.</p>
</li>
<li>
<p>Now implement the exp_pick_up_food, exp_pick_up_coins, exp_pick_up_teleporter and exp_pick_up_torch functions in board.rs.  These functions remove things from a room's contents and add it to the explorer's things.  An explorer does not put down the things she picks up but she can use coins to pay gnomes for passage or have all her things stolen if she cannot or refuses to pay.</p>
</li>
<li>
<p>Next implement the exp_eat_food function in board.rs.  This functions removes all food items from an explorer's things and adds their energy values to the explorer's energy.  An explorer eats any food as soon as she picks it up instead of carrying it around.  Food is destroyed by eating it and is not replenished.  Otherwise the game would never end.</p>
</li>
<li>
<p>Now implement the shake_down function in inventory.rs.  The inventory module defines the encounters or exchanges between players.  These exchanges happen when players are occupants of the same room.  A gnome will demand gold coins from an explorer for safe passage through a room.  If the explorer cannot or chooses not to pay the gnome will take all of the explorer's things.  Hence the name of the function.  An explorer can pay a gnome with fake coins but that only works once.  That same gnome will always rob the explorer of everything on the next encounter.  This function should be highly interactive and decomposed into smaller functions.  See exp_scavenge in board.rs for ideas.</p>
</li>
<li>
<p>Next implement the trick_or_treat function in inventory.rs.  A leprechaun will give an explorer coins or secret words when encountering them.  Concentrate on just coins for now.  A leprechaun starts out with a finite number of gold and fake coins of various denominations.  Those coins are shuffled at creation time so a leprechaun should be able to hand them out one-at-a-time in whatever order they're in.</p>
</li>
<li>
<p>Now implement the gnome_scavenge function in board.rs.  This function makes the game more challenging by enabling gnomes to compete with the explorer for items scattered across the board.  A gnome now picks up all the same things that an explorer picks up in exp_scavenge but it does so automatically rather than interactively because it is an NPC.  Like exp_scavenge, gnome_scavenge can be decomposed into several smaller functions if needbe.  The names and signatures of these smaller functions have not been defined for you.  If you really want to get fancy you can have gnomes stockpile gold and other non-perishable items in certain rooms so that an explorer can pick them up again.</p>
</li>
<li>
<p>Next implement the all_magic_words and all_fake_words functions and finish the trick_or_treat function in inventory.rs.  The first 2 functions supply the leprechaun with magic and fake secret words to give to the explorer.  The list of all magic words can be generated by iterating through all the walls in the game board and filtering out all the walls that aren't magical.  The secret words can then be extracted from the remaining magical walls.  The list of all fake words can be whatever you want as long as it excludes the real magic words from the board.  Make sure it is apparent what secret word is being given to an explorer when trick_or_treat executes.</p>
</li>
<li>
<p>Lastly implement the means for an explorer to walk through magical walls.  There are 3 magical walls placed strategically throughout the board for you to test this feature out on.  While an explorer has no knowledge of what walls are solid or magical you can spot which walls are magical by looking closely at the ASCII rendition of the board. Modify the 4-way explorer navigation functions in players.rs so that if an explorer walks into a wall the user is queried for a secret word that she must type out in its entirety.  Implement the has_word function to search a collection of things for said word.  If said word is found among the explorer's things then call the open_sesame function in board.rs with that word.  In addition to a secret word string, open_sesame also takes an explorer's source and target positions on the board.  If the wall an explorer is attempting to traverse is magical and the secret word matches then open_sesame returns true and the explorer is allowed to pass through the wall.</p>
</li>
</ul>
<p>The original rules for this game came from a homework assignment for an introductory C++ class taught by <a href="http://www.ee.washington.edu/people/jim-peckol">Jim Peckol</a> at the University of Washington.  That class emphasized UML and object-oriented design.  For this Rust workshop, I chose to implement the game in a more functional style using enums and pattern matching for dispatching.  Rust is a multi-paradigm language so the same results could have been achieved using traits and polymorphism.  See Liz Baillie's <a href="https://github.com/tildeio/learning-rust"><em>text-based adventure game</em></a> for an example of such an alternate approach.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="./mondrian-pattern/CONTRIBUTING.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="./url_shortener/README.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./mondrian-pattern/CONTRIBUTING.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./url_shortener/README.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
